/* file : EuclideDGFWriter.java
 * 
 * Project : Euclide
 *
 * ===========================================
 * 
 * This library is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or (at
 * your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library. if not, write to :
 * The Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Created on 8 mai 2007
 *
 */

package io.dgf;

import static java.lang.Math.abs;
import static java.lang.Math.log;
import static java.lang.Math.max;
import static java.lang.Math.pow;
import static java.lang.Math.round;
import gui.util.HtmlColors;

import java.awt.Color;
import java.awt.Dimension;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;

import math.geom2d.Box2D;
import math.geom2d.Measure2D;
import math.geom2d.Point2D;
import math.geom2d.Shape2D;
import math.geom2d.grid.Grid2D;
import math.geom2d.grid.SquareGrid2D;
import math.geom2d.grid.TriangleGrid2D;
import model.EuclideDoc;
import model.EuclideLayer;
import model.EuclideFigure;
import model.EuclideSheet;
import model.style.DrawStyle;
import model.style.Marker;

import org.apache.log4j.Logger;

import app.EuclideApp;

import dynamic.*;
import dynamic.measures.Constant2D;
import dynamic.measures.MeasureWrapper2D;
import dynamic.predicates.BooleanWrapper2D;
import dynamic.shapes.ShapeWrapper2D;

/**
 * Save a File in format DGF: Dynamic Geometry File.
 * 
 * @author dlegland
 */
public class EuclideDGFWriter {

	/** Apache log4j Logger */
	private static Logger logger = Logger.getLogger("Euclide");

	private final static String separatorLine = 
		"# ========================================";
	
	private PrintWriter writer = null;

	private EuclideDoc doc;

	public EuclideDGFWriter(File file) throws IOException {
		super();

		logger.info("Open file "+file.getName()+" for writing document");

		String path = file.getAbsolutePath();
		writer = new PrintWriter(new BufferedWriter(new FileWriter(path)));
	}

	public boolean writeDocument(EuclideDoc doc) throws IOException {
		logger.info("Saving document "+doc.getName());

		// ----------
		// Initializations

		this.doc = doc;

		// ----------
		// Writes general data for document
	
		// file header
		writer.write("#Auto generated by Program Euclide\n");

		writer.write("\n");
		writer.write("EuclideVersion = " + EuclideApp.version + "\n");
		
		// document header
		writer.write("\n");
		writer.write(separatorLine + "\n");
		writer.write("# Data for Document\n");
		writer.write("\n");

		writer.write("# Document header\n");
		writer.write("docName = "+doc.getName()+"\n");
		writer.write("docAuthor = "+doc.getAuthorName()+"\n");

		// Write sheets present in doc
		StringBuffer buffer = new StringBuffer("docSheets =");
		for (EuclideSheet sheet : doc.getSheets()) {
			buffer.append(" ").append(sheet.getTag());
		}
		writer.write(buffer.append("\n").toString());

		// Write doc base style
		writer.write("\n# Document default style\n");
		writeStyle("doc", doc.getDrawStyle());
		
		
		// ----------
		// Writes info for non-shape geometric elements

		writer.write("\n# Document non-shape elements\n");

		// Vectors
		buffer = new StringBuffer("docVectors =");
		for (DynamicVector2D v : doc.getVectors())
			buffer.append(" "+v.getTag());
		writer.write(buffer+"\n");

		// Transforms
		buffer = new StringBuffer("docTransforms =");
		for (DynamicTransform2D t : doc.getTransforms())
			buffer.append(" "+t.getTag());
		writer.write(buffer+"\n");

		// Measures
		buffer = new StringBuffer("docMeasures =");
		for (DynamicMeasure2D m : doc.getMeasures())
			buffer.append(" "+m.getTag());
		writer.write(buffer+"\n");

		// Predicates
		buffer = new StringBuffer("docPredicates =");
		for (DynamicPredicate2D p : doc.getPredicates())
			buffer.append(" "+p.getTag());
		writer.write(buffer+"\n");

		
		// ----------
		// Write info for sheets

		// sheet header
		writer.write("\n");
		writer.write(separatorLine + "\n");
		writer.write("# Data for sheets\n");
		writer.write("\n");

		// Process each sheet
		for (EuclideSheet sheet : doc.getSheets()) {
			this.writeSheet(sheet);
		}

		// ----------
		// Write info for Layers

		// header for layers
		writer.write("\n");
		writer.write(separatorLine + "\n");
		writer.write("# Data for Layers\n");
		writer.write("\n");

		// Process each layer of each sheet
		for (EuclideSheet sheet : doc.getSheets()) {
			for (EuclideLayer layer : sheet.getLayers()) {
				this.writeLayer(layer);
			}
		}

		// ----------
		// Write info for all dynamic objects (constructions)

		// header for dynamic objects
		writer.write("\n");
		writer.write(separatorLine + "\n");
		writer.write("# Data for Geometric objects\n");
		writer.write("# (stored approximately in order of creation)\n");
		writer.write("\n");

		// iterate on all dynamic objects
		for (DynamicObject2D dynamic : doc.getDynamicObjects()) {
			writeConstruction(dynamic);
		}

		writer.write("\n");

		// ----------
		// Write info for shapes (graphical elements which refer to a
		// DynamicShape2D)

		// header for shapes
		writer.write("\n");
		writer.write("# Data for Figures\n");
		writer.write("\n");

		// Process each shape in the document
		for (EuclideFigure shape : doc.getFigures()) {
			writeShape(shape);
		}

		// Small footer at the end if the document
		writer.write("\n");
		writer.write("#End\n");

		return true;
	}

	public void close() {
		writer.close();
	}

	public void writeSheet(EuclideSheet sheet) {
		// compute sheet tag
		String sheetTag = sheet.getTag();

		// name of sheet
		writer.write(sheetTag+"Name"+" = "+sheet.getName()+"\n");

		// size of sheet page
		Dimension dim = sheet.getDimension();
		writer.write(sheetTag+"Size"+" = "+dim.width+" "+dim.height+"\n");

		// view box of the sheet
		Box2D box = sheet.getViewBox();
		writer.format(Locale.US, "%sViewbox = %5.2f %5.2f %5.2f %5.2f\n",
				sheetTag, box.getMinX(), box.getMaxX(), box.getMinY(), box
						.getMaxY());

		// Write grid info
		writeGrid(sheetTag, sheet.getGrid());
		
		// visibility of the grid
		writeTagAttribute(sheetTag, "GridVisible", sheet.isGridVisible());
		
		// layers in sheet
		writer.write(sheetTag+"Layers =");
		for (EuclideLayer layer : sheet.getLayers()) {
			writer.write(" "+layer.getTag());
		}
		writer.write("\n");

		// current layer in the sheet
		EuclideLayer layer = sheet.getCurrentLayer();
		if(layer!=null)
			writeTagAttribute(sheetTag, "CurrentLayer", layer.getTag());
		
		// next sheet
		writer.write("\n");
	}

	private void writeGrid(String sheetTag, Grid2D grid) {
		// write the type of grid only if different from square
		
		if (grid instanceof TriangleGrid2D) {
			TriangleGrid2D triangleGrid = (TriangleGrid2D) grid;
			
			// Write grid type, dependent on grid angle
			double theta = triangleGrid.getTheta();
			String gridType;
			if (Math.abs(theta)<1e-5)
				gridType = "triangleUpDown";
			else
				gridType = "triangleLeftRight";
			writer.format(sheetTag + "GridType" + " = " + gridType + "\n");
			
			// grid size
			writer.format(sheetTag + "GridSize" + " = "
					+ triangleGrid.getSize() + "\n");
			
		} else if (grid instanceof SquareGrid2D) {
			// grid type
			String gridType = "square";
			writer.format(sheetTag + "GridType" + " = " + gridType + "\n");
			
			// grid size
			writer.format(sheetTag+"GridSize"+" = "
					+((SquareGrid2D) grid).getSizeX()+" "
					+((SquareGrid2D) grid).getSizeY()+"\n");
		}
	}
	
	public void writeLayer(EuclideLayer layer) {
		// extract tag
		String tag = layer.getTag();

		// general info for layer
		writeTagAttribute(tag, "Name", layer.getName());
		writeTagAttribute(tag, "Visible", layer.isVisible());
		writeTagAttribute(tag, "Editable", layer.isEditable());
		
		// graphic items present in the layer
		writer.write(tag+"Shapes = ");
		for (EuclideFigure shape : layer.getShapes())
			writer.write(" "+shape.getTag());
		writer.write("\n");
		writer.write("\n");
	}

	public void writeConstruction(DynamicObject2D dyn) {
		// extract tag
		writer.print(dyn.getTag()+" = ");

		// First process special cases, then general case
		Class<?> dynClass = dyn.getClass();
		if (dyn instanceof ShapeWrapper2D) {
			// case of wrapped shapes
			logger.warn("Use of ShapeWrapper2D is deprecated");
			Shape2D shape = ((ShapeWrapper2D) dyn).getShape();
			dynClass = shape.getClass();
			writer.print(dynClass.getSimpleName());
			if (shape instanceof Point2D) {
				Point2D point = (Point2D) shape;
				writer.print(" "+point.getX()+" "+point.getY());
			}
		} else if (dyn instanceof MeasureWrapper2D) {
			// case of measure wrappers
			double value = ((MeasureWrapper2D) dyn).getMeasure().getValue();
			dynClass = dyn.getClass();
			writer.print("MeasureWrapper2D "+value);
		} else if (dyn instanceof Constant2D) {
			// case of constant measures
			Measure2D measure = ((Constant2D) dyn).getMeasure();
			double value = measure.getValue();
			dynClass = dyn.getClass();
			writer.print("Constant2D "+value+" \""+measure.getUnitSymbol()
							+"\"");
		} else if (dyn instanceof DynamicArray2D) {
			// case of a Dynamic array: need to write explicitly
			logger.info("Save a DynamicArray: " + dyn.getTag());
			writer.print(dynClass.getSimpleName());
			writeDynamicArray((DynamicArray2D) dyn);
		} else {
			// other cases
			writer.print(dynClass.getSimpleName());

			// write the tag of each parent
			for (DynamicObject2D parent : dyn.getParents()) {
				writeConstructionParent(parent);
			}

			// write the value of each parameter
			for (Object param : dyn.getParameters()) {
				writeConstructionParameter(param);
			}
		}

		// end of construction line
		writer.write("\n");

		// Also writes the name of the object
		String name = dyn.getName();
		if (name!=null)
			if (!name.isEmpty())
				writer.write(dyn.getTag()+"Name = "+name+"\n");

		// separate each construction by a blank line
		writer.write("\n");
	}

	private void writeConstructionParent(DynamicObject2D parent) {
		if (parent instanceof DynamicArray2D) {
			writeDynamicArray((DynamicArray2D) parent);
		} else if (parent instanceof BooleanWrapper2D) {
			boolean res = ((BooleanWrapper2D) parent).getResult();
			writer.write(" "+(res ? "true" : "false"));
		} else {
			writer.write(" "+parent.getTag());
		}
	}
	
	private void writeDynamicArray(DynamicArray2D array) {
		writer.write(" {");
		for (DynamicObject2D arrayElement : array.getParents())
			writer.write(" "+arrayElement.getTag());
		writer.write("}");
	}

	private void writeConstructionParameter(Object param) {
		if (param instanceof Double) {
			double val = roundValue((Double) param);
			writer.write(" "+val);
		} else if (param instanceof String) {
			writer.write(" \""+param+"\"");
		} else {
			writer.write(" "+param.toString());
		}
	}

	/**
	 * Rounds the given value to avoid having more than around 9 significant
	 * digits.
	 * 
	 * @param val the value to round
	 * @return the rounded value
	 */
	private final static double roundValue(double val) {
		double fact = max(pow(2, log(abs(val))/log(2)+30), 1e10);
		return round(val*fact)/fact;
	}

	public void writeShape(EuclideFigure shape) {

		// extract tag
		String tag = shape.getTag();

		// write geometry
		writer.write(tag+"Geometry = "+shape.getGeometry().getTag()+"\n");

		// Extract current style and doc style (used as reference style)
		DrawStyle docStyle = doc.getDrawStyle();
		DrawStyle style = shape.getDrawStyle();

		// writes the style
		writeStyle(tag, style, docStyle);

		// add some aeration
		writer.write("\n");
	}
	
	/**
	 * Writes style exhaustively
	 */
	private void writeStyle(String tag, DrawStyle style) {

		// write marker style

		// marker type
		writeMarker(tag, style.getMarker());
		
		// marker color
		writeTagAttribute(tag, "MarkerColor", style.getMarkerColor());

		// marker fill color
		writeTagAttribute(tag, "MarkerFill", style.getMarkerFillColor());

		// marker size
		writeTagAttribute(tag, "MarkerSize", style.getMarkerSize());

		// marker size unit
		writeTagAttribute(tag, "MarkerSizeUnit", style.getMarkerSizeUnit());

		// marker line width
		writeTagAttribute(tag, "MarkerWidth", style.getMarkerLineWidth());

		
		// write line style

		// line visibility
		writeTagAttribute(tag, "LineVisible", style.isLineVisible());

		// line width
		writeTagAttribute(tag, "LineWidth", style.getLineWidth());

		// marker size unit
		writeTagAttribute(tag, "LineWidthUnit", style.getLineWidthUnit());

		// line color
		writeTagAttribute(tag, "LineColor", style.getLineColor());

		// line end cap
		writeTagAttribute(tag, "LineEndCap", style.getLineEndCap());
		
		// line join
		writeTagAttribute(tag, "LineJoin", style.getLineJoin());
		
		// line dash
		writeLineDash(tag, style);
		
		// dash phase
		writeTagAttribute(tag, "LinePhase", style.getLineDashPhase());

		// write fill style

		// fill type
		writeTagAttribute(tag, "FillType", style.getFillType());

		// fill color
		writeTagAttribute(tag, "FillColor", style.getFillColor());

		// fill transparency
		writeTagAttribute(tag, "FillTransparency",
				style.getFillTransparency());
	}
	
	/**
	 * Writes only style attributes that differ from base style.
	 */
	private void writeStyle(String tag, DrawStyle style, DrawStyle baseStyle) {

		// write marker style

		// marker type
		if (style.getMarker()!=baseStyle.getMarker())
			writeMarker(tag, style.getMarker());
		
		// marker color
		if (!style.getMarkerColor().equals(baseStyle.getMarkerColor()))
			writeTagAttribute(tag, "MarkerColor", style.getMarkerColor());

		// marker fill color
		if (!style.getMarkerFillColor().equals(baseStyle.getMarkerFillColor()))
			writeTagAttribute(tag, "MarkerFill", style.getMarkerFillColor());

		// marker size
		if (style.getMarkerSize()!=baseStyle.getMarkerSize())
			writeTagAttribute(tag, "MarkerSize", style.getMarkerSize());

		// marker size unit
		if (style.getMarkerSizeUnit()!=baseStyle.getMarkerSizeUnit())
			writeTagAttribute(tag, "MarkerSizeUnit", style.getMarkerSizeUnit());

		// marker line width
		if (style.getMarkerLineWidth()!=baseStyle.getMarkerLineWidth())
			writeTagAttribute(tag, "MarkerWidth", style.getMarkerLineWidth());

		
		// write line style

		// line visibility
		if (style.isLineVisible()!=baseStyle.isLineVisible())
			writeTagAttribute(tag, "LineVisible", style.isLineVisible());

		// line width
		if (style.getLineWidth()!=baseStyle.getLineWidth())
			writeTagAttribute(tag, "LineWidth", style.getLineWidth());

		// line color
		if (!style.getLineColor().equals(baseStyle.getLineColor()))
			writeTagAttribute(tag, "LineColor", style.getLineColor());

		// line width unit
		if (style.getLineWidthUnit()!=baseStyle.getLineWidthUnit())
			writeTagAttribute(tag, "LineWidthUnit", style.getLineWidthUnit());

		// line end cap
		if (style.getLineEndCap()!=baseStyle.getLineEndCap())
			writeTagAttribute(tag, "LineEndCap", style.getLineEndCap());

		// line join
		if (style.getLineJoin()!=baseStyle.getLineJoin())
			writeTagAttribute(tag, "LineJoin", style.getLineJoin());

		// line dash
		if (isDifferentDash(style, baseStyle))
			writeLineDash(tag, style);
		
		// dash phase
		if (style.getLineDashPhase()!=baseStyle.getLineDashPhase())
			writeTagAttribute(tag, "LinePhase", style.getLineDashPhase());

		// write fill style

		// fill type
		if (style.getFillType()!=baseStyle.getFillType())
			writeTagAttribute(tag, "FillType", style.getFillType());

		// fill color
		if (!style.getFillColor().equals(baseStyle.getFillColor()))
			writeTagAttribute(tag, "FillColor", style.getFillColor());

		// fill transparency
		if (style.getFillTransparency()!=baseStyle.getFillTransparency())
			writeTagAttribute(tag, "FillTransparency", 
					style.getFillTransparency());
	}
	
	private void writeMarker(String tag, Marker marker) {
		String markerString = "Circle";
		if (marker.equals(Marker.CIRCLE))
			markerString = "Circle";
		else if (marker.equals(Marker.PLUS))
			markerString = "Plus";
		else if (marker.equals(Marker.CROSS))
			markerString = "Cross";
		else if (marker.equals(Marker.SQUARE))
			markerString = "Square";
		else if (marker.equals(Marker.DIAMOND))
			markerString = "Diamond";
		else {
			logger.error("Unknown marker style for item " + tag);
		}
		writeTagAttribute(tag, "MarkerType", markerString);
	}

	private boolean isDifferentDash(DrawStyle style, DrawStyle baseStyle) {
		float[] dash = style.getLineDash();
		float[] docDash = baseStyle.getLineDash();
		boolean diff = false;
		if (dash!=null) {
			if (dash.length!=docDash.length)
				diff = true;
			if (!diff) {
				for (int i = 0; i<dash.length; i++)
					if (dash[i]!=docDash[i])
						diff = true;
			}
		}
		return diff;
	}
	
	private void writeLineDash(String tag, DrawStyle style) {
		float[] dash = style.getLineDash();
		if (dash.length>0){
			StringBuffer buffer = new StringBuffer(tag+"LineDash = ");
			buffer.append(dash[0]);
			for (int i = 1; i<dash.length; i++)
				buffer.append(",").append(dash[i]);
			writer.write(buffer.append("\n").toString());
		}
	}
	
	/**
	 * Just a shortcut to avoid repeat formatting.
	 */
	private void writeTagAttribute(String tag, String attribute, 
			Object value) {
		writer.write(tag+attribute+ " = " + valueToString(value) + "\n"); 
	}
	
	/**
	 * Converts a value into a string. It returns value.toString for most
	 * cases, except for colors that are parsed into a human-readable name.
	 */
	private String valueToString(Object value) {
		if (value instanceof Color)
			return colorToString((Color) value);
		return value.toString();
	}
	
	/**
	 * Converts a Java awt color into a string such as "green" or "lightgray".
	 * Uses HTML color namesG
	 */
	private final static String colorToString(Color color) {
		return HtmlColors.toString(color);
	}
}
